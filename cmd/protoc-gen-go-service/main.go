package main

import (
	"bytes"
	"fmt"
	"html/template"

	"github.com/iancoleman/strcase"
	"google.golang.org/protobuf/compiler/protogen"
)

var tmpl = `
// Code generated by protoc-gen-go_service. DO NOT EDIT.
// versions:
//	protoc	v{{.Gen.Request.CompilerVersion.Major}}.{{.Gen.Request.CompilerVersion.Minor}}.{{.Gen.Request.CompilerVersion.Patch}}

package {{.File.GoPackageName}}

import (
	"context"
	"github.com/easeq/go-service/client"
)

{{$pkg := .File.GoPackageName}}
{{$streams := .Streams}}

{{range .File.Services}}
{{$serviceName := .GoName}}
{{$serviceNameCamel := (camelCase $serviceName)}}
type {{$serviceName}}GSClient interface {
	{{range .Methods}}
	{{if and (not .Desc.IsStreamingServer) (not .Desc.IsStreamingClient)}}
	{{.GoName}}(ctx context.Context, in *{{.Input.GoIdent.GoName}}, opts ...client.CallOption) (*{{.Output.GoIdent.GoName}}, error)
	{{else}}
	{{.GoName}}(ctx context.Context, in *{{.Input.GoIdent.GoName}}, opts ...client.CallOption) (client.StreamClient, error)
	{{end}}
	{{end}}
}

type {{$serviceNameCamel}}GSClient struct {
	name 	string
	opts   	[]client.DialOption
	client.Client
}

func New{{$serviceName}}GSClient(name string, client client.Client, opts ...client.DialOption) {{$serviceName}}GSClient {
	return &{{$serviceNameCamel}}GSClient{name, opts, client}
}

func (sc *{{$serviceNameCamel}}GSClient) GetServiceName() string {
	return sc.name
}

func (sc *{{$serviceNameCamel}}GSClient) GetDialOptions() []client.DialOption {
	return sc.opts
}

{{range .Methods}}
{{$methodName := .GoName}}
{{$inputName := .Input.GoIdent.GoName}}
{{$outputName := .Output.GoIdent.GoName}}
{{if and (not .Desc.IsStreamingServer) (not .Desc.IsStreamingClient)}}
func (sc *{{$serviceNameCamel}}GSClient) {{$methodName}}(ctx context.Context, in *{{$inputName}}, opts ...client.CallOption) (*{{$outputName}}, error) {
	res := new({{$outputName}})
	err := sc.Call(ctx, sc, "/{{$pkg}}.{{$serviceName}}/{{$methodName}}", in, res, opts...)
	if err != nil {
		return nil, err
	}

	return res, nil
}
{{else}}
func (sc *{{$serviceNameCamel}}GSClient) {{$methodName}}(ctx context.Context, in *{{$inputName}}, opts ...client.CallOption) (client.StreamClient, error) {
	stream, err := sc.Stream(ctx, sc, &_{{$serviceName}}_serviceDesc.Streams[{{index $streams (printf "%s%s" .Parent.GoName .GoName)}}], "/{{$pkg}}.{{$serviceName}}/{{$methodName}}", in, opts...)
	if err != nil {
		return nil, err
	}

	return stream, nil
}
{{end}}
{{end}}
{{end}}
`

type Generator struct {
	File    *protogen.File
	Gen     *protogen.Plugin
	Streams map[string]int
}

func main() {
	protogen.Options{}.Run(run)
}

func run(gen *protogen.Plugin) error {
	for _, f := range gen.Files {
		if !f.Generate {
			continue
		}

		generateFile(gen, f)
	}
	return nil
}

// generateFile generates a _ascii.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	ss := make(map[string]int)
	for _, service := range file.Services {
		index := 0
		for _, method := range service.Methods {
			if method.Desc.IsStreamingServer() || method.Desc.IsStreamingClient() {
				ss[fmt.Sprintf("%s%s", service.GoName, method.GoName)] = index
				index++
			}
		}
	}

	generator := &Generator{file, gen, ss}
	filename := file.GeneratedFilenamePrefix + ".pb.gs.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	t, err := template.New("gs.tmpl").Funcs(template.FuncMap{
		"camelCase": strcase.ToLowerCamel,
		"add": func(x, y int) int {
			x = x + y
			return x
		},
	}).Parse(tmpl)
	if err != nil {
		panic(err)
	}

	var result bytes.Buffer
	if err := t.Execute(&result, generator); err != nil {
		panic(err)
	}

	g.P(result.String())

	// for _, service := range file.Services {
	// 	for _, method := range service.Methods {
	// 		log.Println(method.Location)
	// 	}
	// }

	return g
}
