package generator

func GetTemplate() string {
	return tmpl
}

var tmpl = `
// Code generated by protoc-gen-go_service. DO NOT EDIT.
// versions:
//	protoc	v{{.Gen.Request.CompilerVersion.Major}}.{{.Gen.Request.CompilerVersion.Minor}}.{{.Gen.Request.CompilerVersion.Patch}}

package {{.GoPackageName}}

import (
	"context"
	"os"

	"github.com/easeq/go-service/client"
	"github.com/easeq/go-service/server"
)

{{$pkg := .GoPackageName}}
{{$streams := .Streams}}

{{range .Services}}
{{$serviceName := .GoName}}
{{$serviceNameCamel := (camelCase $serviceName)}}
type {{$serviceName}}GSClient interface {
	{{range .Methods -}}
	{{if and (not .Desc.IsStreamingServer) (not .Desc.IsStreamingClient) -}}
	{{.GoName}}(ctx context.Context, in *{{.Input.GoIdent.GoName}}, opts ...client.CallOption) (*{{.Output.GoIdent.GoName}}, error)
	{{else -}}
	{{.GoName}}(ctx context.Context, in *{{.Input.GoIdent.GoName}}, opts ...client.CallOption) (client.StreamClient, error)
	{{end}}
	{{- end}}
}

type {{$serviceNameCamel}}GSClient struct {
	name 	string
	opts   	[]client.DialOption
	client.Client
}

func New{{$serviceName}}GSClient(name string, client client.Client, opts ...client.DialOption) {{$serviceName}}GSClient {
	return &{{$serviceNameCamel}}GSClient{name, opts, client}
}

func (sc *{{$serviceNameCamel}}GSClient) GetServiceName() string {
	return sc.name
}

func (sc *{{$serviceNameCamel}}GSClient) GetDialOptions() []client.DialOption {
	return sc.opts
}

{{range .Methods}}
{{$methodName := .GoName}}
{{$inputName := .Input.GoIdent.GoName}}
{{$outputName := .Output.GoIdent.GoName}}
{{if and (not .Desc.IsStreamingServer) (not .Desc.IsStreamingClient)}}
func (sc *{{$serviceNameCamel}}GSClient) {{$methodName}}(ctx context.Context, in *{{$inputName}}, opts ...client.CallOption) (*{{$outputName}}, error) {
	res := new({{$outputName}})
	err := sc.Call(ctx, sc, "/{{$pkg}}.{{$serviceName}}/{{$methodName}}", in, res, opts...)
	if err != nil {
		return nil, err
	}

	return res, nil
}
{{else}}
func (sc *{{$serviceNameCamel}}GSClient) {{$methodName}}(ctx context.Context, in *{{$inputName}}, opts ...client.CallOption) (client.StreamClient, error) {
	stream, err := sc.Stream(ctx, sc, &_{{$serviceName}}_serviceDesc.Streams[{{index $streams (printf "%s%s" .Parent.GoName .GoName)}}], "/{{$pkg}}.{{$serviceName}}/{{$methodName}}", in, opts...)
	if err != nil {
		return nil, err
	}

	return stream, nil
}
{{end}}
{{end}}
{{end}}

// Add the tags to the registry
func AddRegistryTags(server server.Server) {
	tags := []string{
		{{range .RegistryTags -}}
		"traefik.http.routers.{{.Name}}.rule=Host(` + "`" + `" + os.Getenv("{{.Host}}") + "` + "`" + `) && PathPrefix('{{.Path}}')",
		{{if .Stripprefix -}}
		"traefik.http.middlewares.{{.Name}}-stripprefix.stripprefix.prefixes={{.Stripprefix}}",
		"traefik.http.routers.{{.Name}}.middlewares={{.Name}}-stripprefix@docker",
		{{- end}}
		{{- end}}
	}

	if len(tags) > 0 {
		tags = append(tags, "traefik.enable=true")
	}

	server.SetTags(tags...)
}
`
